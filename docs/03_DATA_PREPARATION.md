# Подготовка данных для обучения модели

## Обзор

Модули для подготовки данных по золоту (XAUUSD) для обучения Transformer модели классификации торговых сигналов.

## Классификация сигналов

Модель классифицирует 5 типов сигналов:

### 0. Неопределенность (Uncertainty)
- **Условие**: движение < порогов или отсутствие четкого направления
- **Характеристика**: слабое движение, боковой тренд
- **Использование**: воздержание от торговли

### 1. Пробой вверх (Breakout Up) - BUY
- **Условие**: будущая доходность > 200 пунктов вверх
- **Характеристика**: сильное движение вверх без значительного разворота
- **Использование**: вход в длинную позицию

### 2. Пробой вниз (Breakout Down) - SELL
- **Условие**: будущая доходность < -200 пунктов (движение вниз)
- **Характеристика**: сильное движение вниз без значительного разворота
- **Использование**: вход в короткую позицию

### 3. Отскок вверх (Bounce Up) - BUY после падения
- **Условие**: разворот после падения, доходность меняет знак, движение > 150 пунктов вверх
- **Характеристика**: начальное движение вниз, затем разворот вверх
- **Использование**: вход в длинную позицию после подтверждения разворота (отложенный вход)

### 4. Отскок вниз (Bounce Down) - SELL после роста
- **Условие**: разворот после роста, доходность меняет знак, движение < -150 пунктов (вниз)
- **Характеристика**: начальное движение вверх, затем разворот вниз
- **Использование**: вход в короткую позицию после подтверждения разворота (отложенный вход)

## Модули

### `data/target_generator.py`

Класс `TargetGenerator` для генерации целевых переменных:

```python
from data.target_generator import TargetGenerator

generator = TargetGenerator(
    breakout_threshold=450.0,  # Порог для пробоя в пунктах (по умолчанию 450)
    bounce_threshold=350.0,    # Порог для отскока в пунктах (по умолчанию 350)
    lookahead_periods=60       # Количество периодов вперед (минуты)
)

# Генерация целевых переменных
df_with_targets = generator.generate_targets(df, price_column='close')
```

**Методы:**
- `generate_targets()` - генерация всех целевых переменных
- `get_class_distribution()` - анализ распределения классов
- `balance_classes()` - балансировка классов (если нужно)

### `data/gold_data_prep.py`

Класс `GoldDataPreparator` для подготовки данных по золоту:

```python
from data.gold_data_prep import GoldDataPreparator

preparator = GoldDataPreparator(
    training_months=6  # Количество месяцев данных
)

# Подготовка полного датасета
df = preparator.prepare_full_dataset(
    symbol='XAUUSD',
    months=6,
    load_ticks=True,
    load_higher_tf=True
)
```

**Методы:**
- `load_gold_data()` - загрузка минутных данных (автоматически создает из тиков, если данных недостаточно)
- `load_higher_timeframes()` - загрузка старших таймфреймов
- `load_tick_data()` - загрузка тиковых данных
- `prepare_full_dataset()` - полная подготовка датасета
- `save_prepared_data()` / `load_prepared_data()` - сохранение/загрузка

**Особенность**: Если минутных данных недостаточно (брокер хранит только 3-6 месяцев), система автоматически:
1. Загружает тики за недостающие периоды
2. Создает минутные свечи из тиков
3. Объединяет данные из MT5 и созданные из тиков

### `data/data_splitter.py`

Класс `DataSplitter` для разделения данных:

```python
from data.data_splitter import DataSplitter

# Временное разделение (по умолчанию, для реальной торговли)
splitter = DataSplitter(
    train_ratio=0.7,
    val_ratio=0.15,
    test_ratio=0.15,
    temporal_split=True  # Временное разделение (без перемешивания)
)

# Случайное разделение со стратификацией (для экспериментов)
splitter_random = DataSplitter(
    train_ratio=0.7,
    val_ratio=0.15,
    test_ratio=0.15,
    temporal_split=False  # Случайное разделение (с перемешиванием)
)

train_df, val_df, test_df = splitter.split(df, target_column='signal_class', stratify=True)
```

**Методы:**
- `split()` - разделение данных (с опциональной стратификацией)
- `get_class_distribution()` - анализ распределения классов

**Параметры:**
- `temporal_split=True`: временное разделение (сохраняет временной порядок)
- `temporal_split=False`: случайное разделение (со стратификацией по классам)

## Использование

### Быстрый старт

Запустите скрипт подготовки данных:

```bash
# Базовое использование (6 месяцев)
python prepare_gold_data.py

# 12 месяцев
python prepare_gold_data.py --months 12

# Указать количество дней (приоритет над --months)
python prepare_gold_data.py --days 30
python prepare_gold_data.py -d 7

# Справка по всем параметрам
python prepare_gold_data.py --help
```

Скрипт:
1. Загрузит данные по золоту (6 месяцев по умолчанию, можно указать через `--months` или `--days`)
2. Загрузит тиковые данные и старшие таймфреймы (можно отключить через `--no-ticks` или `--no-higher-tf`)
3. Сгенерирует все фичи (с автоматическим сохранением прогресса)
4. Создаст целевые переменные
5. Разделит данные на train/val/test
6. Сохранит результаты в файлы

### Параметры командной строки

```bash
# Количество месяцев
python prepare_gold_data.py -m 12
python prepare_gold_data.py --months 12

# Количество дней (приоритет над --months)
python prepare_gold_data.py --days 30
python prepare_gold_data.py -d 7

# Без тиков
python prepare_gold_data.py -m 12 --no-ticks

# Без старших таймфреймов
python prepare_gold_data.py -m 12 --no-higher-tf

# Принудительная регенерация (игнорировать кэш)
python prepare_gold_data.py -m 12 --force

# Не использовать кэш вообще
python prepare_gold_data.py -m 12 --no-cache

# Автоматически загружать сохраненные данные (не спрашивать)
python prepare_gold_data.py -m 12 --no-ask

# Комбинация параметров
python prepare_gold_data.py -m 12 --no-ask --force

# Для экспериментов: случайное разделение со стратификацией
python prepare_gold_data.py --no-temporal-split

# Для реальной торговли: временное разделение с балансировкой классов
python prepare_gold_data.py --balance-classes --balance-method undersample
```

**Все параметры:**
- `-m, --months` - количество месяцев данных (по умолчанию: 6)
- `-d, --days` - количество дней данных (приоритет над --months)
- `--symbol` - торговый символ (по умолчанию: XAUUSD)
- `--no-ticks` - не загружать тиковые данные
- `--no-higher-tf` - не загружать старшие таймфреймы
- `--force` - принудительно регенерировать данные (игнорировать кэш)
- `--no-cache` - не использовать кэш (не сохранять и не загружать)
- `--no-ask` - не спрашивать при наличии сохраненных данных (автоматически загружать)
- `--offline` - режим offline - работа только с кэшированными данными без подключения к MT5
- `--no-temporal-split` - использовать случайное разделение со стратификацией вместо временного (для экспериментов)
- `--balance-classes` - балансировать классы после разделения (только для temporal_split)
- `--balance-method` - метод балансировки: `undersample` (по умолчанию) или `oversample`

### Режим offline (без подключения к MT5)

Для работы на Linux машинах или без доступа к MT5 можно использовать режим offline:

```bash
# Подготовка данных в offline режиме (только из кэша)
python prepare_gold_data.py --offline --days 30

# Полный цикл в offline режиме
python full_pipeline.py --offline --days 30
```

**Требования для offline режима:**
- Тики должны быть загружены в `workspace/raw_data/ticks/`
- Данные должны покрывать требуемый период
- MT5 не требуется (можно запускать на Linux)

**Как это работает:**
1. Загружает тики из кэша `workspace/raw_data/ticks/`
2. Создает минутные свечи из тиков
3. Создает старшие таймфреймы через агрегацию из минутных данных
4. Генерирует фичи и целевые переменные

**Преимущества:**
- ✅ Работа на Linux без MT5
- ✅ Использование только кэшированных данных
- ✅ Старшие таймфреймы создаются автоматически из минутных данных
- ✅ Полная совместимость с обычным режимом

### Программное использование

```python
from data.gold_data_prep import GoldDataPreparator
from data.data_splitter import DataSplitter

# Подготовка данных (обычный режим)
preparator = GoldDataPreparator(training_months=6)
df = preparator.prepare_full_dataset(
    symbol='XAUUSD',
    months=6,
    load_ticks=True,
    load_higher_tf=True
)

# Подготовка данных (offline режим)
preparator_offline = GoldDataPreparator(training_months=6, offline_mode=True)
df = preparator_offline.prepare_full_dataset(
    symbol='XAUUSD',
    days=30,
    load_ticks=True,
    load_higher_tf=True
)

# Разделение данных
splitter = DataSplitter(temporal_split=True)
train_df, val_df, test_df = splitter.split(df)

# Сохранение
train_df.to_csv('workspace/prepared/features/gold_train.csv')
val_df.to_csv('workspace/prepared/features/gold_val.csv')
test_df.to_csv('workspace/prepared/features/gold_test.csv')
```

## Параметры

### Количество месяцев данных

Можно указать любое количество месяцев:

```python
# 6 месяцев (по умолчанию)
preparator = GoldDataPreparator(training_months=6)

# 1 год
preparator = GoldDataPreparator(training_months=12)

# 3 месяца (для быстрого тестирования)
preparator = GoldDataPreparator(training_months=3)
```

### Пороги для классификации

Можно настроить пороги для пробоя и отскока:

```python
from data.target_generator import TargetGenerator

generator = TargetGenerator(
    breakout_threshold=450.0,  # Порог пробоя (пункты, по умолчанию 450)
    bounce_threshold=350.0,    # Порог отскока (пункты, по умолчанию 350)
    lookahead_periods=60       # Период анализа (минуты)
)
```

## Выходные файлы

После подготовки данных создаются файлы:

- `workspace/prepared/features/gold_data_{months}months.csv` - полный датасет
- `workspace/prepared/features/gold_train.csv` - обучающая выборка (70%)
- `workspace/prepared/features/gold_val.csv` - валидационная выборка (15%)
- `workspace/prepared/features/gold_test.csv` - тестовая выборка (15%)

## Структура данных

Подготовленный DataFrame содержит:

- **Фичи**: все сгенерированные фичи (ценовые, технические, тиковые и т.д.)
- **Целевые переменные**:
  - `signal_class`: числовой класс (0, 1, 2)
  - `signal_class_name`: название класса ('uncertainty', 'breakout', 'bounce')
  - `future_return_N`: доходности на разных периодах
  - `max_future_return`: максимальная будущая доходность

## Кэширование и сохранение прогресса

### Автоматическое сохранение

Система автоматически сохраняет прогресс на каждом этапе:

1. **Промежуточные фичи** (`workspace/raw_data/cache/`):
   - Сохраняются после каждого этапа генерации фичей
   - При прерывании процесс продолжается с последнего этапа
   - Автоматически очищаются после успешного завершения

2. **Тиковые данные** (`workspace/raw_data/ticks/`):
   - Кэшируются по дням в формате `{symbol}_{YYYYMMDD}.parquet` (кроссплатформенный формат)
   - Поддерживается обратная совместимость с pickle файлами (автоматическая конвертация)
   - При загрузке тиков для минутных свечей система **сначала проверяет кэш** для каждой свечи
   - Загружает из MT5 **только недостающие** тики (оптимизированная логика)
   - Показывает статистику использования кэша (сколько данных из кэша vs из MT5)
   - Прогресс батчевой загрузки сохраняется
   - При прерывании продолжается с последней обработанной свечи
   - **Важно**: По умолчанию система не загружает весь диапазон кэша заранее (1.5 года), 
     а загружает тики по требованию. Это ускоряет работу, если данные уже в кэше.
   - **Кроссплатформенность**: Parquet формат обеспечивает совместимость между Windows и Linux

3. **Финальный датасет** (`workspace/raw_data/cache/`):
   - Сохраняется в кэш с уникальным именем на основе параметров
   - При повторном запуске с теми же параметрами загружается из кэша
   - Имя файла: `{symbol}_{months}m_{date}_{ticks_flag}_{tf_flag}.pkl`

### Возобновление после прерывания

Если процесс был прерван (Ctrl+C, ошибка, перезагрузка):

1. **Генерация фичей**: автоматически продолжается с последнего сохраненного этапа
2. **Загрузка тиков**: автоматически продолжается с последней обработанной свечи
3. **Финальный датасет**: если уже был создан, загружается из кэша

### Управление кэшем

```python
# Принудительная регенерация (игнорировать кэш)
df = preparator.prepare_full_dataset(
    months=12,
    force_regenerate=True
)

# Не использовать кэш вообще
df = preparator.prepare_full_dataset(
    months=12,
    use_cache=False
)

# Автоматически загружать сохраненные данные (не спрашивать)
df = preparator.prepare_full_dataset(
    months=12,
    ask_on_existing=False
)
```

## Оптимизация фичей

### Удаление высококоррелированных фичей

Можно включить автоматическое удаление высококоррелированных фичей:

```python
from config.feature_config import FeatureConfig

config = FeatureConfig(
    remove_correlated_features=True,  # Включить удаление
    correlation_threshold=0.95        # Порог корреляции
)
```

Или использовать отдельный скрипт для анализа:

```bash
python analyze_feature_correlation.py --remove --threshold 0.95
```

Подробнее см. [11_FEATURE_OPTIMIZATION.md](11_FEATURE_OPTIMIZATION.md)

## Визуализация данных обучения

Для визуализации подготовленных данных с сигналами и точками закрытия используется скрипт `utils/visualize_training_data.py`:

```bash
# Визуализация последних 5 дней (по умолчанию)
python utils/visualize_training_data.py

# Визуализация последних 10 дней
python utils/visualize_training_data.py --days 10

# Визуализация с конкретной даты
python utils/visualize_training_data.py --start-date 2024-01-01 --days 7

# Сохранение графика в файл
python utils/visualize_training_data.py --output workspace/results/training_visualization.png

# Показать также неопределенность (класс 0)
python utils/visualize_training_data.py --show-uncertainty
```

**Что отображается на графике:**

- **Свечной график**: минутные свечи (open, high, low, close)
- **Маркеры сигналов**: 
  - Зеленый треугольник вверх (^) - пробой вверх (класс 1) и отскок вверх (класс 3)
  - Красный треугольник вниз (v) - пробой вниз (класс 2) и отскок вниз (класс 4)
- **Линии к точкам закрытия**: пунктирные линии от сигнала к точке закрытия
- **Точки закрытия**: крестики (x) показывают, где должен закрыться сигнал согласно разметке

**Параметры:**

- `--input`: путь к файлу с данными (по умолчанию: `workspace/prepared/features/gold_train.csv`)
- `--days`: количество дней для отображения (по умолчанию: 5)
- `--start-date`: начальная дата в формате YYYY-MM-DD
- `--output`: путь для сохранения графика (если не указан, показывается на экране)
- `--show-uncertainty`: показывать неопределенность (класс 0) на графике

## Разделение данных и балансировка классов

### Временное vs случайное разделение

#### Временное разделение (`temporal_split=True`) - РЕКОМЕНДУЕТСЯ для продакшена

**Как работает:**
- Данные разделяются строго по времени без перемешивания
- Train: первые 70% данных по времени (например, июнь-октябрь)
- Val: следующие 15% данных (например, октябрь)
- Test: последние 15% данных (например, ноябрь)
- Модель обучается на прошлом, валидируется на настоящем, тестируется на будущем

**Когда использовать:**
✅ **Используйте для:**
- Реальной торговли и продакшена
- Бэктестинга стратегий
- Оценки реальной производительности модели
- Когда важна реалистичность оценки
- Финальной валидации перед запуском в продакшен

**Плюсы:**
- ✅ Реалистично моделирует реальные условия торговли
- ✅ Нет утечки данных из будущего (модель не видит будущее при обучении)
- ✅ Отражает реальные изменения рыночных условий
- ✅ Подходит для оценки устойчивости модели к изменениям рынка

**Минусы:**
- ❌ Распределение классов может сильно отличаться между периодами
  - Например: Train имеет 50% класса 0, Val/Test имеют 10% класса 0
  - Это может привести к плохой генерализации модели
- ❌ Статистики фичей могут различаться (разные рыночные условия)
- ❌ Модель может переобучиться на специфические условия train периода

**Решение проблем:**
- Используйте `--balance-classes` для балансировки классов
- Проверяйте распределение: `python check_data_distribution.py`
- Используйте больше данных для обучения (12+ месяцев)

**Пример использования:**
```bash
# Для реальной торговли с балансировкой классов
python prepare_gold_data.py --months 12 --balance-classes --balance-method undersample

# Для бэктестинга без балансировки (если распределение классов схоже)
python prepare_gold_data.py --months 6
```

---

#### Случайное разделение (`temporal_split=False`) - ТОЛЬКО для экспериментов

**Как работает:**
- Данные перемешиваются случайным образом
- Train/Val/Test содержат данные из всех периодов
- Сохраняется одинаковое распределение классов (стратификация)
- Модель может "видеть" будущее при обучении (утечка данных)

**Когда использовать:**
✅ **Используйте для:**
- Быстрого прототипирования и экспериментов
- Тестирования архитектуры модели
- Сравнения разных подходов к обучению
- Отладки и разработки
- Когда нужно быстро проверить идею

❌ **НЕ используйте для:**
- Реальной торговли
- Финальной оценки модели
- Бэктестинга
- Продакшена

**Плюсы:**
- ✅ Одинаковое распределение классов в train/val/test
- ✅ Проще обучать модель (нет дисбаланса классов)
- ✅ Быстрее получить результаты для экспериментов
- ✅ Хорошо для сравнения разных моделей на одинаковых данных

**Минусы:**
- ❌ **Критично**: утечка данных из будущего
  - Модель обучается на данных, которые содержат информацию о будущем
  - Это не отражает реальные условия торговли
  - Результаты будут завышены и нереалистичны
- ❌ Не подходит для оценки реальной производительности
- ❌ Может скрыть проблемы с генерализацией модели

**Пример использования:**
```bash
# Для быстрых экспериментов
python prepare_gold_data.py --months 6 --no-temporal-split

# Для тестирования архитектуры модели
python prepare_gold_data.py --months 3 --no-temporal-split
```

---

#### Сравнительная таблица

| Критерий | Временное разделение | Случайное разделение |
|----------|---------------------|---------------------|
| **Временной порядок** | ✅ Сохраняется | ❌ Нарушается |
| **Утечка данных** | ✅ Нет | ❌ Есть (критично!) |
| **Распределение классов** | ⚠️ Может отличаться | ✅ Одинаковое |
| **Реалистичность** | ✅ Высокая | ❌ Низкая |
| **Для продакшена** | ✅ Да | ❌ Нет |
| **Для экспериментов** | ⚠️ Медленнее | ✅ Быстрее |
| **Балансировка классов** | ✅ Рекомендуется | ❌ Не нужна |

---

#### Рекомендации по выбору

**Сценарий 1: Разработка и эксперименты**
```bash
# Быстрое тестирование идеи
python prepare_gold_data.py --months 3 --no-temporal-split
python train_all_models.py --encoder-only --epochs 20
```
→ Используйте случайное разделение для быстрых результатов

**Сценарий 2: Оптимизация модели**
```bash
# Тестирование разных архитектур
python prepare_gold_data.py --months 6 --no-temporal-split
# Сравните несколько моделей
```
→ Используйте случайное разделение для справедливого сравнения

**Сценарий 3: Финальная подготовка к продакшену**
```bash
# Реалистичная оценка производительности
python prepare_gold_data.py --months 12 --balance-classes --balance-method undersample
python check_data_distribution.py  # Проверьте распределение
python train_all_models.py --encoder-only --epochs 100
```
→ Используйте временное разделение с балансировкой

**Сценарий 4: Бэктестинг**
```bash
# Реалистичный бэктест
python prepare_gold_data.py --months 12
python backtest_strategy.py
```
→ Используйте временное разделение без балансировки (если распределение классов схоже)

### Балансировка классов

При использовании временного разделения распределение классов может сильно отличаться между train/val/test (например, в одном периоде 50% класса 0, в другом - 10%).

**Балансировка классов** (`--balance-classes`) решает эту проблему:

- **Undersample** (по умолчанию): уменьшает большие классы до размера меньшего
  - Сохраняет временной порядок
  - Теряет часть данных
  - Рекомендуется для реальной торговли

- **Oversample**: увеличивает малые классы до размера большего
  - Сохраняет временной порядок
  - Дублирует данные (может привести к переобучению)
  - Используйте с осторожностью

**Примеры:**

```bash
# Временное разделение с балансировкой (рекомендуется для реальной торговли)
python prepare_gold_data.py --months 6 --balance-classes --balance-method undersample

# Случайное разделение (для экспериментов, балансировка не нужна)
python prepare_gold_data.py --months 6 --no-temporal-split

# Временное разделение без балансировки (может быть дисбаланс классов)
python prepare_gold_data.py --months 6
```

**Важно:**
- Балансировка применяется только при `temporal_split=True`
- При `--no-temporal-split` балансировка не нужна (стратификация уже обеспечивает одинаковое распределение)
- После балансировки проверьте распределение: `python check_data_distribution.py`

### Проверка распределения данных

После подготовки данных рекомендуется проверить распределение:

```bash
# Проверка распределения train/val/test
python check_data_distribution.py

# Без графиков
python check_data_distribution.py --no-plots
```

Скрипт проверяет:
- **Временное распределение**: нет ли перекрытий между выборками
- **Распределение классов**: одинаково ли распределение классов в train/val/test
- **Статистики фичей**: нет ли значительных различий в статистиках фичей

**Интерпретация результатов:**
- ✅ Нет проблем: все проверки пройдены
- ⚠️ Различия в распределении классов: рассмотрите использование `--balance-classes` или `--no-temporal-split`
- ⚠️ Различия в статистиках фичей: это нормально для временного разделения (разные рыночные условия), но может указывать на проблемы

Подробнее см. [check_data_distribution.py](../check_data_distribution.py)

## Следующие шаги

После подготовки данных можно:
1. Проверить распределение данных: `python check_data_distribution.py`
2. Проанализировать корреляцию фичей (опционально)
3. Загрузить данные для обучения модели
4. Обучить модель(и) через `train_all_models.py`
5. Провести бэктестинг стратегии
6. Оценить результаты

